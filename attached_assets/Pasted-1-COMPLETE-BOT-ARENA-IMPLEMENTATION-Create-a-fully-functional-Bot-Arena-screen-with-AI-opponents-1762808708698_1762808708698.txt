1. COMPLETE BOT ARENA IMPLEMENTATION

Create a fully functional Bot Arena screen with AI opponents of varying difficulty levels. This must be production-ready, not a placeholder.

COMPLETE IMPLEMENTATION:

FILE: /screens/battles/BotArenaScreen.js

import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TouchableOpacity, Animated, StyleSheet, Alert, ScrollView } from 'react-native';
import { doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { auth, db } from '../../config/firebase';
import {
createBotOpponent,
calculateDamage,
checkCriticalHit,
checkDodge,
getBotAIStrategy,
calculateBotRewards,
} from '../../utils/battleLogic';

export default function BotArenaScreen({ navigation }) {
// State management
const [selectedDifficulty, setSelectedDifficulty] = useState('medium');
const [gameState, setGameState] = useState('setup'); // setup, battle, results
const [playerPet, setPlayerPet] = useState(null);
const [botPet, setBotPet] = useState(null);
const [playerHealth, setPlayerHealth] = useState(100);
const [botHealth, setBotHealth] = useState(100);
const [playerTurn, setPlayerTurn] = useState(true);
const [battleLog, setBattleLog] = useState([]);
const [userEnergy, setUserEnergy] = useState(100);
const [botStats, setBotStats] = useState({
easy: { wins: 0, losses: 0 },
medium: { wins: 0, losses: 0 },
hard: { wins: 0, losses: 0 },
});

// Animations
const playerShake = useRef(new Animated.Value(0)).current;
const botShake = useRef(new Animated.Value(0)).current;

useEffect(() => {
loadUserData();
}, []);

const loadUserData = async () => {
try {
const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
const data = userDoc.data();

  setPlayerPet(data.pets);
  setUserEnergy(data.energy || 100);
  setBotStats(data.botBattles || {
    easy: { wins: 0, losses: 0 },
    medium: { wins: 0, losses: 0 },
    hard: { wins: 0, losses: 0 },
  });
} catch (error) {
  console.error('Error loading user data:', error);
  Alert.alert('Error', 'Failed to load data');
}
};

const startBattle = () => {
if (userEnergy < 10) {
Alert.alert('Not Enough Energy', 'You need 10 energy to battle. Wait for it to regenerate!');
return;
}

// Create bot opponent
const bot = createBotOpponent(selectedDifficulty, playerPet);
setBotPet(bot);

// Reset battle state
setPlayerHealth(100);
setBotHealth(100);
setBattleLog([`Battle started against ${bot.name} (${selectedDifficulty})!`]);

// Determine first turn based on agility
const playerGoesFirst = playerPet.baseStats.agility >= bot.baseStats.agility;
setPlayerTurn(playerGoesFirst);

if (playerGoesFirst) {
  addLog('You have first strike!');
} else {
  addLog(`${bot.name} has first strike!`);
  setTimeout(() => botAttack(), 1500);
}

setGameState('battle');

};

const addLog = (message) => {
setBattleLog(prev => [message, ...prev].slice(0, 10));
};

const shakeAnimation = (target) => {
const anim = target === 'player' ? playerShake : botShake;
Animated.sequence([
Animated.timing(anim, { toValue: 10, duration: 50, useNativeDriver: true }),
Animated.timing(anim, { toValue: -10, duration: 50, useNativeDriver: true }),
Animated.timing(anim, { toValue: 10, duration: 50, useNativeDriver: true }),
Animated.timing(anim, { toValue: 0, duration: 50, useNativeDriver: true }),
]).start();
};

const playerMove = (moveType) => {
if (!playerTurn || gameState !== 'battle') return;

setPlayerTurn(false);

if (moveType === 'defend') {
  addLog('You brace for defense!');
  setTimeout(() => botAttack(0.5), 1000); // Reduced damage
  return;
}

const damage = calculateDamage(playerPet, botPet, moveType);
const isCrit = checkCriticalHit(playerPet);
const dodged = checkDodge(botPet);

if (dodged) {
  addLog('Bot dodged your attack!');
  setTimeout(() => botAttack(), 1500);
  return;
}

const finalDamage = isCrit ? damage * 2 : damage;
const newBotHealth = Math.max(0, botHealth - finalDamage);
setBotHealth(newBotHealth);
shakeAnimation('bot');

const moveText = moveType === 'attack' ? 'attacked' : 'used special move on';
addLog(
  `You ${moveText} ${botPet.name} for ${Math.round(finalDamage)} damage!` +
  (isCrit ? ' CRITICAL HIT!' : '')
);

if (newBotHealth <= 0) {
  endBattle('victory');
  return;
}

setTimeout(() => botAttack(), 1500);


};

const botAttack = (damageMultiplier = 1) => {
if (gameState !== 'battle') return;

const aiMove = getBotAIStrategy(
  selectedDifficulty,
  botHealth,
  playerHealth,
  battleLog.length
);

if (aiMove === 'defend') {
  addLog(`${botPet.name} defends!`);
  setPlayerTurn(true);
  return;
}

const damage = calculateDamage(botPet, playerPet, aiMove) * damageMultiplier;
const isCrit = checkCriticalHit(botPet);
const dodged = checkDodge(playerPet);

if (dodged) {
  addLog('You dodged the attack!');
  setPlayerTurn(true);
  return;
}

const finalDamage = isCrit ? damage * 2 : damage;
const newPlayerHealth = Math.max(0, playerHealth - finalDamage);
setPlayerHealth(newPlayerHealth);
shakeAnimation('player');

const moveText = aiMove === 'attack' ? 'attacked' : 'used special move on';
addLog(
  `${botPet.name} ${moveText} you for ${Math.round(finalDamage)} damage!` +
  (isCrit ? ' CRITICAL HIT!' : '')
);

if (newPlayerHealth <= 0) {
  endBattle('defeat');
  return;
}

setPlayerTurn(true);
};

const endBattle = async (result) => {
setGameState('results');
try {
  const userRef = doc(db, 'users', auth.currentUser.uid);
  const rewards = calculateBotRewards(selectedDifficulty, result === 'victory');

  // Update stats
  const statPath = `botBattles.${selectedDifficulty}.${result === 'victory' ? 'wins' : 'losses'}`;
  
  await updateDoc(userRef, {
    gems: increment(rewards.gems),
    energy: increment(-10),
    totalXP: increment(rewards.xp),
    [statPath]: increment(1),
  });

  // Show results
  const message = result === 'victory'
    ? `ğŸ‰ VICTORY! ğŸ‰\n\nYou defeated ${botPet.name}!\n\nGems earned: ${rewards.gems} ğŸ’\nXP earned: ${rewards.xp}\nEnergy used: 10 âš¡`
    : `ğŸ’” Defeat\n\n${botPet.name} won the battle.\n\nGems lost: ${Math.abs(rewards.gems)} ğŸ’\nXP earned: ${rewards.xp}\nEnergy used: 10 âš¡`;

  Alert.alert(
    result === 'victory' ? 'Victory!' : 'Defeat',
    message,
    [{ text: 'Continue', onPress: () => loadUserData() }]
  );
} catch (error) {
  console.error('Error ending battle:', error);
  Alert.alert('Error', 'Failed to save battle results');
}

};

const resetBattle = () => {
setGameState('setup');
setBotPet(null);
setPlayerHealth(100);
setBotHealth(100);
setBattleLog([]);
setPlayerTurn(true);
};

if (!playerPet) {
return (
<View style={styles.loading}>
<Text>Loading...</Text>
</View>
);
}

// SETUP SCREEN
if (gameState === 'setup') {
return (
<ScrollView style={styles.container}>
<View style={styles.header}>
<Text style={styles.title}>ğŸ¤– Bot Arena</Text>
<Text style={styles.subtitle}>Practice against AI opponents</Text>
</View>

    <View style={styles.energyDisplay}>
      <Text style={styles.energyText}>âš¡ Energy: {userEnergy}/100</Text>
    </View>

    {/* Difficulty Selection */}
    <View style={styles.difficultySection}>
      <Text style={styles.sectionTitle}>Select Difficulty</Text>

      <TouchableOpacity
        style={[
          styles.difficultyCard,
          selectedDifficulty === 'easy' && styles.difficultyCardSelected
        ]}
        onPress={() => setSelectedDifficulty('easy')}
      >
        <View style={styles.difficultyHeader}>
          <Text style={styles.difficultyIcon}>ğŸ˜Š</Text>
          <Text style={styles.difficultyName}>Easy</Text>
        </View>
        <Text style={styles.difficultyDesc}>Bot 20% weaker than you</Text>
        <View style={styles.rewardsRow}>
          <Text style={styles.rewardText}>ğŸ’ Win: 5-8 gems</Text>
          <Text style={styles.rewardText}>ğŸ’ Lose: -3 gems</Text>
        </View>
        <View style={styles.statsRow}>
          <Text style={styles.statsText}>
            W: {botStats.easy.wins} L: {botStats.easy.losses}
          </Text>
        </View>
      </TouchableOpacity>

      <TouchableOpacity
        style={[
          styles.difficultyCard,
          selectedDifficulty === 'medium' && styles.difficultyCardSelected
        ]}
        onPress={() => setSelectedDifficulty('medium')}
      >
        <View style={styles.difficultyHeader}>
          <Text style={styles.difficultyIcon}>ğŸ˜</Text>
          <Text style={styles.difficultyName}>Medium</Text>
        </View>
        <Text style={styles.difficultyDesc}>Bot equal to your level</Text>
        <View style={styles.rewardsRow}>
          <Text style={styles.rewardText}>ğŸ’ Win: 8-12 gems</Text>
          <Text style={styles.rewardText}>ğŸ’ Lose: -5 gems</Text>
        </View>
        <View style={styles.statsRow}>
          <Text style={styles.statsText}>
            W: {botStats.medium.wins} L: {botStats.medium.losses}
          </Text>
        </View>
      </TouchableOpacity>

      <TouchableOpacity
        style={[
          styles.difficultyCard,
          selectedDifficulty === 'hard' && styles.difficultyCardSelected
        ]}
        onPress={() => setSelectedDifficulty('hard')}
      >
        <View style={styles.difficultyHeader}>
          <Text style={styles.difficultyIcon}>ğŸ˜¤</Text>
          <Text style={styles.difficultyName}>Hard</Text>
        </View>
        <Text style={styles.difficultyDesc}>Bot 20% stronger than you</Text>
        <View style={styles.rewardsRow}>
          <Text style={styles.rewardText}>ğŸ’ Win: 12-15 gems</Text>
          <Text style={styles.rewardText}>ğŸ’ Lose: -8 gems</Text>
        </View>
        <View style={styles.statsRow}>
          <Text style={styles.statsText}>
            W: {botStats.hard.wins} L: {botStats.hard.losses}
          </Text>
        </View>
      </TouchableOpacity>
    </View>

    {/* Battle Info */}
    <View style={styles.infoCard}>
      <Text style={styles.infoTitle}>â„¹ï¸ Battle Info</Text>
      <Text style={styles.infoText}>-  Costs 10 energy per battle</Text>
      <Text style={styles.infoText}>-  Win bonus: +50 XP</Text>
      <Text style={styles.infoText}>-  Lower stakes than PvP</Text>
      <Text style={styles.infoText}>-  Great for practice!</Text>
    </View>

    <TouchableOpacity
      style={styles.startBtn}
      onPress={startBattle}
      disabled={userEnergy < 10}
    >
      <Text style={styles.startBtnText}>
        {userEnergy < 10 ? 'Not Enough Energy' : 'âš”ï¸ Start Battle (10âš¡)'}
      </Text>
    </TouchableOpacity>
  </ScrollView>
);


}

// BATTLE SCREEN
if (gameState === 'battle') {
const healthPercentage = (health) => Math.max(0, health);

return (
  <View style={styles.battleContainer}>
    {/* Bot Pet */}
    <Animated.View 
      style={[
        styles.petContainer,
        styles.botContainer,
        { transform: [{ translateX: botShake }] }
      ]}
    >
      <Text style={styles.petName}>{botPet.name}</Text>
      <Text style={styles.petLevel}>Lv. {botPet.level}</Text>
      <View style={styles.petPlaceholder}>
        <Text style={styles.petEmoji}>ğŸ¤–</Text>
      </View>
      <View style={styles.healthBarContainer}>
        <View 
          style={[
            styles.healthBar,
            { width: `${healthPercentage(botHealth)}%` },
            botHealth < 30 && styles.healthBarLow
          ]}
        />
      </View>
      <Text style={styles.healthText}>{Math.round(botHealth)}/100 HP</Text>
    </Animated.View>

    {/* Battle Log */}
    <View style={styles.battleLogContainer}>
      {battleLog.slice(0, 3).map((log, index) => (
        <Text key={index} style={styles.logText}>{log}</Text>
      ))}
    </View>

    {/* Player Pet */}
    <Animated.View 
      style={[
        styles.petContainer,
        styles.playerContainer,
        { transform: [{ translateX: playerShake }] }
      ]}
    >
      <Text style={styles.petName}>{playerPet.name}</Text>
      <Text style={styles.petLevel}>Lv. {playerPet.level}</Text>
      <View style={styles.petPlaceholder}>
        <Text style={styles.petEmoji}>ğŸ¾</Text>
      </View>
      <View style={styles.healthBarContainer}>
        <View 
          style={[
            styles.healthBar,
            { width: `${healthPercentage(playerHealth)}%` },
            playerHealth < 30 && styles.healthBarLow
          ]}
        />
      </View>
      <Text style={styles.healthText}>{Math.round(playerHealth)}/100 HP</Text>
    </Animated.View>

    {/* Battle Controls */}
    <View style={styles.controls}>
      <TouchableOpacity
        style={[styles.moveBtn, !playerTurn && styles.moveBtnDisabled]}
        onPress={() => playerMove('attack')}
        disabled={!playerTurn}
      >
        <Text style={styles.moveBtnText}>âš”ï¸ Attack</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.moveBtn, styles.defendBtn, !playerTurn && styles.moveBtnDisabled]}
        onPress={() => playerMove('defend')}
        disabled={!playerTurn}
      >
        <Text style={styles.moveBtnText}>ğŸ›¡ï¸ Defend</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.moveBtn, styles.specialBtn, !playerTurn && styles.moveBtnDisabled]}
        onPress={() => playerMove('special')}
        disabled={!playerTurn}
      >
        <Text style={styles.moveBtnText}>âœ¨ Special</Text>
      </TouchableOpacity>
    </View>

    {!playerTurn && (
      <Text style={styles.waitingText}>Bot's turn...</Text>
    )}
  </View>
);


}

// RESULTS SCREEN (handled by Alert, returns to setup)
return null;
}

const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#F5F5F5',
},
loading: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
header: {
backgroundColor: '#5D9CEC',
padding: 30,
alignItems: 'center',
},
title: {
fontSize: 28,
fontWeight: 'bold',
color: 'white',
marginBottom: 5,
},
subtitle: {
fontSize: 16,
color: 'rgba(255,255,255,0.9)',
},
energyDisplay: {
backgroundColor: 'white',
marginHorizontal: 20,
marginTop: -15,
padding: 12,
borderRadius: 10,
alignItems: 'center',
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.1,
shadowRadius: 4,
elevation: 3,
},
energyText: {
fontSize: 16,
fontWeight: 'bold',
color: '#333',
},
difficultySection: {
padding: 20,
},
sectionTitle: {
fontSize: 20,
fontWeight: 'bold',
marginBottom: 15,
color: '#333',
},
difficultyCard: {
backgroundColor: 'white',
borderRadius: 12,
padding: 15,
marginBottom: 12,
borderWidth: 2,
borderColor: 'transparent',
},
difficultyCardSelected: {
borderColor: '#5D9CEC',
backgroundColor: '#F0F7FF',
},
difficultyHeader: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 8,
},
difficultyIcon: {
fontSize: 24,
marginRight: 10,
},
difficultyName: {
fontSize: 18,
fontWeight: 'bold',
color: '#333',
},
difficultyDesc: {
fontSize: 14,
color: '#666',
marginBottom: 10,
},
rewardsRow: {
flexDirection: 'row',
justifyContent: 'space-between',
marginBottom: 8,
},
rewardText: {
fontSize: 12,
color: '#32808D',
fontWeight: '600',
},
statsRow: {
borderTopWidth: 1,
borderTopColor: '#E0E0E0',
paddingTop: 8,
},
statsText: {
fontSize: 12,
color: '#666',
},
infoCard: {
backgroundColor: 'white',
margin: 20,
padding: 15,
borderRadius: 10,
},
infoTitle: {
fontSize: 16,
fontWeight: 'bold',
marginBottom: 10,
color: '#333',
},
infoText: {
fontSize: 14,
color: '#666',
marginBottom: 5,
},
startBtn: {
backgroundColor: '#5D9CEC',
marginHorizontal: 20,
marginBottom: 30,
padding: 18,
borderRadius: 10,
alignItems: 'center',
},
startBtnText: {
color: 'white',
fontSize: 18,
fontWeight: 'bold',
},

// Battle Screen Styles
battleContainer: {
flex: 1,
backgroundColor: '#F5F5F5',
},
petContainer: {
alignItems: 'center',
padding: 20,
},
botContainer: {
backgroundColor: '#FFE5E5',
},
playerContainer: {
backgroundColor: '#E5F5FF',
},
petName: {
fontSize: 20,
fontWeight: 'bold',
color: '#333',
},
petLevel: {
fontSize: 14,
color: '#666',
marginBottom: 10,
},
petPlaceholder: {
width: 100,
height: 100,
backgroundColor: 'rgba(255,255,255,0.5)',
borderRadius: 50,
justifyContent: 'center',
alignItems: 'center',
marginBottom: 10,
},
petEmoji: {
fontSize: 50,
},
healthBarContainer: {
width: '80%',
height: 20,
backgroundColor: '#DDD',
borderRadius: 10,
overflow: 'hidden',
marginBottom: 5,
},
healthBar: {
height: '100%',
backgroundColor: '#4CAF50',
},
healthBarLow: {
backgroundColor: '#FF5252',
},
healthText: {
fontSize: 14,
fontWeight: 'bold',
color: '#333',
},
battleLogContainer: {
backgroundColor: 'white',
padding: 15,
marginHorizontal: 20,
borderRadius: 10,
minHeight: 80,
},
logText: {
fontSize: 12,
color: '#666',
marginBottom: 5,
},
controls: {
flexDirection: 'row',
justifyContent: 'space-around',
padding: 20,
},
moveBtn: {
backgroundColor: '#32808D',
paddingVertical: 15,
paddingHorizontal: 20,
borderRadius: 10,
minWidth: 100,
alignItems: 'center',
},
defendBtn: {
backgroundColor: '#5D9CEC',
},
specialBtn: {
backgroundColor: '#A463BF',
},
moveBtnDisabled: {
backgroundColor: '#CCC',
opacity: 0.5,
},
moveBtnText: {
color: 'white',
fontSize: 14,
fontWeight: 'bold',
},
waitingText: {
textAlign: 'center',
fontSize: 16,
color: '#666',
fontStyle: 'italic',
},
});


2. COMPLETE PET RUNNER GAME

Create a fully functional endless runner game (Chrome dinosaur style) where the pet jumps over obstacles. This must be production-ready and playable immediately.

COMPLETE IMPLEMENTATION:

FILE: /screens/battles/RunnerGameScreen.js


import React, { useState, useEffect, useRef } from 'react';
import {
View,
Text,
TouchableOpacity,
Animated,
StyleSheet,
Alert,
Dimensions,
Modal,
} from 'react-native';
import { doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { auth, db } from '../../config/firebase';
import { checkDailyLimit, calculateRunnerReward } from '../../utils/runnerRewards';

const SCREEN_WIDTH = Dimensions.get('window').width;
const SCREEN_HEIGHT = Dimensions.get('window').height;
const GROUND_HEIGHT = 150;
const PET_SIZE = 60;
const OBSTACLE_WIDTH = 40;
const JUMP_HEIGHT = 120;
const GRAVITY = 1200;
const INITIAL_SPEED = 300;

export default function RunnerGameScreen({ navigation }) {
// Game state
const [gameState, setGameState] = useState('ready'); // ready, playing, gameOver
const [score, setScore] = useState(0);
const [highScore, setHighScore] = useState(0);
const [speed, setSpeed] = useState(INITIAL_SPEED);
const [obstacles, setObstacles] = useState([]);
const [userEnergy, setUserEnergy] = useState(100);
const [dailyGems, setDailyGems] = useState(0);
const [petAgility, setPetAgility] = useState(70);

// Animations
const petY = useRef(new Animated.Value(0)).current;
const isJumping = useRef(false);
const gameLoop = useRef(null);
const obstacleSpawnTimer = useRef(null);
const lastFrameTime = useRef(Date.now());

useEffect(() => {
loadGameData();
return () => {
if (gameLoop.current) clearInterval(gameLoop.current);
if (obstacleSpawnTimer.current) clearInterval(obstacleSpawnTimer.current);
};
}, []);

const loadGameData = async () => {
try {
const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
const data = userDoc.data();
  setHighScore(data.runnerBestScore || 0);
  setUserEnergy(data.energy || 100);
  setDailyGems(data.runnerDailyGems || 0);
  setPetAgility(data.pets?.baseStats.agility || 70);
} catch (error) {
  console.error('Error loading game data:', error);
}

};

const startGame = () => {
if (userEnergy < 5) {
Alert.alert('Not Enough Energy', 'You need 5 energy to play. Wait for it to regenerate!');
return;
}
// Reset game state
setScore(0);
setSpeed(INITIAL_SPEED);
setObstacles([]);
petY.setValue(0);
isJumping.current = false;
lastFrameTime.current = Date.now();

setGameState('playing');

// Start game loop
gameLoop.current = setInterval(updateGame, 16); // ~60 FPS

// Start spawning obstacles
spawnObstacle();
obstacleSpawnTimer.current = setInterval(spawnObstacle, 2000);

};

const spawnObstacle = () => {
const types = [
{ height: 40, width: 30, type: 'low', icon: 'ğŸª¨' },
{ height: 60, width: 35, type: 'medium', icon: 'ğŸŒµ' },
{ height: 50, width: 40, type: 'wide', icon: 'â›°ï¸' },
];

const obstacleType = types[Math.floor(Math.random() * types.length)];

setObstacles(prev => [...prev, {
  id: Date.now(),
  x: SCREEN_WIDTH,
  ...obstacleType,
}]);

};

const updateGame = () => {
const now = Date.now();
const deltaTime = (now - lastFrameTime.current) / 1000;
lastFrameTime.current = now;

// Move obstacles
setObstacles(prev => {
  const updated = prev.map(obs => ({
    ...obs,
    x: obs.x - speed * deltaTime,
  })).filter(obs => obs.x > -OBSTACLE_WIDTH);

  // Check collision
  updated.forEach(obs => {
    if (checkCollision(obs)) {
      endGame();
    }
  });

  return updated;
});

// Increase score
setScore(prev => {
  const newScore = prev + deltaTime * 10;
  
  // Increase speed every 100 points
  if (Math.floor(newScore / 100) > Math.floor(prev / 100)) {
    setSpeed(s => Math.min(s + 30, 600));
  }
  
  return newScore;
});

};

const checkCollision = (obstacle) => {
const petBottom = GROUND_HEIGHT - petY._value;
const petTop = petBottom - PET_SIZE;
const petLeft = 50;
const petRight = petLeft + PET_SIZE;

const obsLeft = obstacle.x;
const obsRight = obstacle.x + obstacle.width;
const obsTop = GROUND_HEIGHT - obstacle.height;
const obsBottom = GROUND_HEIGHT;

// Check overlap
const overlap = 
  petRight > obsLeft &&
  petLeft < obsRight &&
  petBottom > obsTop &&
  petTop < obsBottom;

return overlap;
};

const jump = () => {
if (isJumping.current || gameState !== 'playing') return;

isJumping.current = true;

// Jump height affected by pet agility
const jumpBoost = (petAgility / 100) * 30; // 0-30 extra height
const totalJumpHeight = JUMP_HEIGHT + jumpBoost;

Animated.sequence([
  Animated.timing(petY, {
    toValue: totalJumpHeight,
    duration: 350,
    useNativeDriver: true,
  }),
  Animated.timing(petY, {
    toValue: 0,
    duration: 350,
    useNativeDriver: true,
  }),
]).start(() => {
  isJumping.current = false;
});


};

const endGame = async () => {
setGameState('gameOver');

if (gameLoop.current) clearInterval(gameLoop.current);
if (obstacleSpawnTimer.current) clearInterval(obstacleSpawnTimer.current);

const finalScore = Math.floor(score);

try {
  // Deduct energy
  await updateDoc(doc(db, 'users', auth.currentUser.uid), {
    energy: increment(-5),
  });

  // Calculate and award gems
  const rewardResult = await calculateRunnerReward(auth.currentUser.uid, finalScore);

  // Update high score if beaten
  if (finalScore > highScore) {
    setHighScore(finalScore);
  }

  // Show results
  showResults(finalScore, rewardResult);
} catch (error) {
  console.error('Error ending game:', error);
  Alert.alert('Error', 'Failed to save game results');
}

};

const showResults = (finalScore, rewardResult) => {
let message = Score: ${finalScore}\n\n;

if (rewardResult.limitReached) {
  message += `âš ï¸ Daily gem limit reached (50/50)\n\nCome back tomorrow for more gems!`;
} else {
  message += `ğŸ’ Gems earned: ${rewardResult.gems}\n`;
  message += `ğŸ“Š Daily total: ${dailyGems + rewardResult.gems}/50\n\n`;
  
  if (rewardResult.isNewHighScore) {
    message += `ğŸ‰ NEW HIGH SCORE! ğŸ‰`;
  }
}

Alert.alert(
  'Game Over!',
  message,
  [
    { text: 'Back to Menu', onPress: () => navigation.goBack() },
    { text: 'Play Again', onPress: () => {
      loadGameData();
      setGameState('ready');
    }},
  ]
);


};

// READY SCREEN
if (gameState === 'ready') {
return (
<View style={styles.container}>
<View style={styles.header}>
<Text style={styles.title}>ğŸƒ Pet Runner</Text>
<Text style={styles.subtitle}>Endless obstacle course</Text>
</View>

    <View style={styles.infoCard}>
      <Text style={styles.infoTitle}>How to Play</Text>
      <Text style={styles.infoText}>-  Tap anywhere to jump</Text>
      <Text style={styles.infoText}>-  Avoid obstacles</Text>
      <Text style={styles.infoText}>-  Game speeds up over time</Text>
      <Text style={styles.infoText}>-  Earn 1 gem per 10 points</Text>
      <Text style={styles.infoText}>-  Bonus at 50+ points!</Text>
    </View>

    <View style={styles.statsCard}>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>âš¡ Energy Cost</Text>
        <Text style={styles.statValue}>5</Text>
      </View>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>ğŸ† High Score</Text>
        <Text style={styles.statValue}>{highScore}</Text>
      </View>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>ğŸ’ Today's Gems</Text>
        <Text style={styles.statValue}>{dailyGems}/50</Text>
      </View>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>âš¡ Current Energy</Text>
        <Text style={styles.statValue}>{userEnergy}/100</Text>
      </View>
    </View>

    <View style={styles.agilityCard}>
      <Text style={styles.agilityText}>
        ğŸ¦˜ Your pet's agility: {petAgility}
      </Text>
      <Text style={styles.agilityDesc}>
        Higher agility = higher jumps!
      </Text>
    </View>

    <TouchableOpacity
      style={[styles.startBtn, userEnergy < 5 && styles.startBtnDisabled]}
      onPress={startGame}
      disabled={userEnergy < 5}
    >
      <Text style={styles.startBtnText}>
        {userEnergy < 5 ? 'Not Enough Energy' : 'â–¶ï¸ Start Game'}
      </Text>
    </TouchableOpacity>

    <TouchableOpacity
      style={styles.backBtn}
      onPress={() => navigation.goBack()}
    >
      <Text style={styles.backBtnText}>â† Back to Battle Modes</Text>
    </TouchableOpacity>
  </View>
);

}

// GAME SCREEN
return (
<TouchableOpacity style={styles.gameContainer} activeOpacity={1} onPress={jump} >
{/* Sky Background */}
<View style={styles.sky}>
<Text style={styles.scoreDisplay}>Score: {Math.floor(score)}</Text>
</View>

  {/* Ground */}
  <View style={[styles.ground, { bottom: 0, height: GROUND_HEIGHT }]}>
    <View style={styles.groundLine} />
    
    {/* Pet */}
    <Animated.View
      style={[
        styles.pet,
        {
          bottom: petY,
          left: 50,
        },
      ]}
    >
      <Text style={styles.petIcon}>ğŸ¾</Text>
    </Animated.View>

    {/* Obstacles */}
    {obstacles.map(obstacle => (
      <View
        key={obstacle.id}
        style={[
          styles.obstacle,
          {
            left: obstacle.x,
            bottom: 0,
            width: obstacle.width,
            height: obstacle.height,
          },
        ]}
      >
        <Text style={styles.obstacleIcon}>{obstacle.icon}</Text>
      </View>
    ))}
  </View>

  {/* Instructions */}
  <View style={styles.instructions}>
    <Text style={styles.instructionText}>ğŸ‘† TAP TO JUMP</Text>
  </View>
</TouchableOpacity>

);
}

const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#F5F5F5',
},
header: {
backgroundColor: '#A463BF',
padding: 30,
alignItems: 'center',
},
title: {
fontSize: 28,
fontWeight: 'bold',
color: 'white',
marginBottom: 5,
},
subtitle: {
fontSize: 16,
color: 'rgba(255,255,255,0.9)',
},
infoCard: {
backgroundColor: 'white',
margin: 20,
padding: 20,
borderRadius: 12,
shadowColor: '#000',
shadowOffset: { width: 0, height: 2 },
shadowOpacity: 0.1,
shadowRadius: 4,
elevation: 3,
},
infoTitle: {
fontSize: 18,
fontWeight: 'bold',
marginBottom: 12,
color: '#333',
},
infoText: {
fontSize: 14,
color: '#666',
marginBottom: 6,
},
statsCard: {
backgroundColor: 'white',
marginHorizontal: 20,
marginBottom: 20,
padding: 15,
borderRadius: 12,
},
statRow: {
flexDirection: 'row',
justifyContent: 'space-between',
paddingVertical: 10,
borderBottomWidth: 1,
borderBottomColor: '#F0F0F0',
},
statLabel: {
fontSize: 14,
color: '#666',
},
statValue: {
fontSize: 14,
fontWeight: 'bold',
color: '#A463BF',
},
agilityCard: {
backgroundColor: '#F0E6FF',
marginHorizontal: 20,
marginBottom: 20,
padding: 15,
borderRadius: 12,
alignItems: 'center',
},
agilityText: {
fontSize: 16,
fontWeight: 'bold',
color: '#A463BF',
marginBottom: 5,
},
agilityDesc: {
fontSize: 12,
color: '#666',
},
startBtn: {
backgroundColor: '#A463BF',
marginHorizontal: 20,
marginBottom: 15,
padding: 18,
borderRadius: 12,
alignItems: 'center',
},
startBtnDisabled: {
backgroundColor: '#CCC',
},
startBtnText: {
color: 'white',
fontSize: 18,
fontWeight: 'bold',
},
backBtn: {
marginHorizontal: 20,
marginBottom: 30,
padding: 15,
alignItems: 'center',
},
backBtnText: {
color: '#A463BF',
fontSize: 16,
},

// Game Screen Styles
gameContainer: {
flex: 1,
backgroundColor: '#87CEEB', // Sky blue
},
sky: {
flex: 1,
justifyContent: 'flex-start',
alignItems: 'center',
paddingTop: 40,
},
scoreDisplay: {
fontSize: 32,
fontWeight: 'bold',
color: 'white',
textShadowColor: 'rgba(0, 0, 0, 0.3)',
textShadowOffset: { width: 2, height: 2 },
textShadowRadius: 4,
},
ground: {
position: 'absolute',
width: '100%',
backgroundColor: '#8B7355',
},
groundLine: {
position: 'absolute',
top: 0,
width: '100%',
height: 3,
backgroundColor: '#654321',
},
pet: {
position: 'absolute',
width: PET_SIZE,
height: PET_SIZE,
justifyContent: 'center',
alignItems: 'center',
},
petIcon: {
fontSize: 50,
},
obstacle: {
position: 'absolute',
justifyContent: 'center',
alignItems: 'center',
},
obstacleIcon: {
fontSize: 35,
},
instructions: {
position: 'absolute',
bottom: GROUND_HEIGHT + 20,
width: '100%',
alignItems: 'center',
},
instructionText: {
fontSize: 24,
fontWeight: 'bold',
color: 'white',
textShadowColor: 'rgba(0, 0, 0, 0.5)',
textShadowOffset: { width: 2, height: 2 },
textShadowRadius: 4,
},
});


Now create the rewards calculator:

FILE: /utils/runnerRewards.js


import { doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { db } from '../config/firebase';

const DAILY_GEM_LIMIT = 50;
const GEMS_PER_10_POINTS = 1;
const BONUS_GEMS_AT_50_POINTS = 5;

export const checkDailyLimit = async (userId) => {
const userRef = doc(db, 'users', userId);
const userDoc = await getDoc(userRef);
const data = userDoc.data();

const today = new Date().toDateString();
const lastPlayed = data.runnerLastPlayedDate?.toDate().toDateString();

// Reset if new day
if (lastPlayed !== today) {
await updateDoc(userRef, {
runnerDailyGems: 0,
runnerLastPlayedDate: new Date(),
});
return { canEarn: true, currentDaily: 0, remaining: DAILY_GEM_LIMIT };
}

const currentDaily = data.runnerDailyGems || 0;
const canEarn = currentDaily < DAILY_GEM_LIMIT;

return {
canEarn,
currentDaily,
remaining: DAILY_GEM_LIMIT - currentDaily
};
};

export const calculateRunnerReward = async (userId, score) => {
const limitCheck = await checkDailyLimit(userId);

if (!limitCheck.canEarn) {
return {
gems: 0,
message: 'Daily gem limit reached! Come back tomorrow.',
limitReached: true,
isNewHighScore: false,
remaining: 0,
};
}

// Calculate gems from score
let baseGems = Math.floor(score / 10) * GEMS_PER_10_POINTS;

// Bonus for 50+ score
if (score >= 50) {
baseGems += BONUS_GEMS_AT_50_POINTS;
}

// Cap at remaining daily limit
const gemsToAward = Math.min(baseGems, limitCheck.remaining);

// Update Firebase
const userRef = doc(db, 'users', userId);
await updateDoc(userRef, {
gems: increment(gemsToAward),
runnerDailyGems: increment(gemsToAward),
runnerTotalGames: increment(1),
});

// Check high score
const userDoc = await getDoc(userRef);
const currentBest = userDoc.data().runnerBestScore || 0;
const isNewHighScore = score > currentBest;

if (isNewHighScore) {
await updateDoc(userRef, {
runnerBestScore: score,
});
}

return {
gems: gemsToAward,
message: You earned ${gemsToAward} gems!,
limitReached: false,
isNewHighScore,
remaining: limitCheck.remaining - gemsToAward,
};
};

