Update the Pet Runner game to display the user's actual pet and implement unique mechanics for different pet types (land animals run/jump, birds/dragons fly).

REQUIREMENTS:

1. FIRST, UPDATE PET DATA STRUCTURE:

FILE: /config/petsData.js (UPDATE)

export const STARTER_PETS = [
{
id: 'vigor_dog',
name: 'Vigor',
type: 'Dog',
category: 'land', // land or flying
icon: 'üêï',
runningIcon: 'üêï‚Äçü¶∫', // Animation frame
jumpingIcon: 'üêï',
description: 'A loyal companion perfect for running',
baseStats: {
health: 75,
energy: 80,
strength: 70,
defense: 65,
stamina: 85,
agility: 75,
attack: 70,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Vigor Pup', icon: 'üêï' },
{ tier: 2, level: 10, name: 'Vigor Hound', icon: 'üêï‚Äçü¶∫' },
{ tier: 3, level: 25, name: 'Alpha Vigor', icon: 'ü¶Æ' },
],
runnerAbility: {
name: 'Sprint Burst',
description: 'Temporary speed boost when jumping',
effect: 'speedOnJump',
},
},
{
id: 'zen_cat',
name: 'Zen',
type: 'Cat',
category: 'land',
icon: 'üê±',
runningIcon: 'üêà',
jumpingIcon: 'üê±',
description: 'Agile and balanced for meditation',
baseStats: {
health: 70,
energy: 85,
strength: 65,
defense: 60,
stamina: 75,
agility: 90, // Cats are most agile
attack: 70,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Zen Kitten', icon: 'üê±' },
{ tier: 2, level: 10, name: 'Zen Feline', icon: 'üêà' },
{ tier: 3, level: 25, name: 'Mystic Zen', icon: 'üêÜ' },
],
runnerAbility: {
name: 'Nine Lives',
description: 'Extra chance to survive a hit',
effect: 'extraLife',
},
},
{
id: 'atlas_bear',
name: 'Atlas',
type: 'Bear',
category: 'land',
icon: 'üêª',
runningIcon: 'üêª‚Äç‚ùÑÔ∏è',
jumpingIcon: 'üêª',
description: 'Strong and enduring for stamina',
baseStats: {
health: 90,
energy: 75,
strength: 85,
defense: 80,
stamina: 90,
agility: 60,
attack: 80,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Atlas Cub', icon: 'üêª' },
{ tier: 2, level: 10, name: 'Atlas Grizzly', icon: 'üêª‚Äç‚ùÑÔ∏è' },
{ tier: 3, level: 25, name: 'Titan Atlas', icon: 'üß∏' },
],
runnerAbility: {
name: 'Tough Hide',
description: 'Destroys small obstacles on contact',
effect: 'destroyObstacles',
},
},
{
id: 'swift_rabbit',
name: 'Swift',
type: 'Rabbit',
category: 'land',
icon: 'üê∞',
runningIcon: 'üêá',
jumpingIcon: 'üê∞',
description: 'Lightning fast and energetic',
baseStats: {
health: 65,
energy: 90,
strength: 60,
defense: 55,
stamina: 80,
agility: 95, // Fastest
attack: 65,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Swift Bunny', icon: 'üê∞' },
{ tier: 2, level: 10, name: 'Swift Hare', icon: 'üêá' },
{ tier: 3, level: 25, name: 'Lightning Swift', icon: '‚ö°üê∞' },
],
runnerAbility: {
name: 'Triple Jump',
description: 'Can jump 3 times in the air',
effect: 'tripleJump',
},
},
// FLYING PETS
{
id: 'aero_bird',
name: 'Aero',
type: 'Bird',
category: 'flying',
icon: 'üê¶',
flyingIcon: 'ü¶Ö',
glidingIcon: 'üïäÔ∏è',
description: 'Graceful flyer with aerial mastery',
baseStats: {
health: 60,
energy: 95,
strength: 65,
defense: 55,
stamina: 85,
agility: 88,
attack: 70,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Aero Chick', icon: 'üê¶' },
{ tier: 2, level: 10, name: 'Aero Eagle', icon: 'ü¶Ö' },
{ tier: 3, level: 25, name: 'Sky Master Aero', icon: 'ü¶ö' },
],
runnerAbility: {
name: 'Glide',
description: 'Tap to flap, release to glide',
effect: 'flappyControl',
},
},
// PREMIUM PETS
{
id: 'phoenix',
name: 'Phoenix',
type: 'Mythical Bird',
category: 'flying',
icon: 'üî•ü¶Ö',
flyingIcon: 'üî•ü¶Ö',
glidingIcon: '‚ú®üïäÔ∏è',
premium: true,
description: 'Legendary firebird with resurrection',
baseStats: {
health: 85,
energy: 95,
strength: 80,
defense: 75,
stamina: 90,
agility: 92,
attack: 90,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Phoenix Hatchling', icon: 'üî•üê¶' },
{ tier: 2, level: 10, name: 'Phoenix Rising', icon: 'üî•ü¶Ö' },
{ tier: 3, level: 25, name: 'Eternal Phoenix', icon: '‚ú®üî•ü¶Ö' },
],
runnerAbility: {
name: 'Rebirth',
description: 'Resurrect once per game after death',
effect: 'resurrect',
},
},
{
id: 'dragon',
name: 'Dragon',
type: 'Legendary Dragon',
category: 'flying',
icon: 'üêâ',
flyingIcon: 'üê≤',
glidingIcon: 'üêâ',
premium: true,
description: 'Powerful dragon with fire breath',
baseStats: {
health: 95,
energy: 90,
strength: 95,
defense: 90,
stamina: 88,
agility: 85,
attack: 100,
},
evolutionTree: [
{ tier: 1, level: 1, name: 'Dragon Wyrmling', icon: 'üêâ' },
{ tier: 2, level: 10, name: 'Dragon Wyrm', icon: 'üê≤' },
{ tier: 3, level: 25, name: 'Ancient Dragon', icon: 'üî•üê≤' },
],
runnerAbility: {
name: 'Fire Breath',
description: 'Destroy obstacles with fire',
effect: 'fireBreath',
},
},
];


2. UPDATE RUNNER GAME WITH PET-SPECIFIC MECHANICS:

FILE: /screens/battles/RunnerGameScreen.js (COMPLETE REPLACEMENT)

import React, { useState, useEffect, useRef } from 'react';
import {
View,
Text,
TouchableOpacity,
Animated,
StyleSheet,
Alert,
Dimensions,
ScrollView,
Easing,
} from 'react-native';
import { doc, getDoc, updateDoc, increment } from 'firebase/firestore';
import { auth, db } from '../../config/firebase';
import { calculateRunnerReward } from '../../utils/runnerRewards';
import { STARTER_PETS } from '../../config/petsData';

const SCREEN_WIDTH = Dimensions.get('window').width;
const GAME_HEIGHT = 500;
const GROUND_HEIGHT = 100;
const PET_SIZE = 50;

// Land pet physics
const LAND_JUMP_VELOCITY = -450;
const LAND_GRAVITY = 1400;

// Flying pet physics
const FLYING_FLAP_FORCE = -350;
const FLYING_GRAVITY = 800;
const FLYING_MAX_FALL_SPEED = 400;

const INITIAL_SPEED = 250;

export default function RunnerGameScreen({ navigation }) {
// Game state
const [gameState, setGameState] = useState('ready');
const [score, setScore] = useState(0);
const [coins, setCoins] = useState(0);
const [distance, setDistance] = useState(0);
const [highScore, setHighScore] = useState(0);
const [speed, setSpeed] = useState(INITIAL_SPEED);

// Pet data
const [petData, setPetData] = useState(null);
const [petConfig, setPetConfig] = useState(null);
const [isFlying, setIsFlying] = useState(false);

// Game objects
const [obstacles, setObstacles] = useState([]);
const [platforms, setPlatforms] = useState([]);
const [coinsList, setCoinsList] = useState([]);
const [powerUps, setPowerUps] = useState([]);

// Player state
const [isOnGround, setIsOnGround] = useState(true);
const [velocityY, setVelocityY] = useState(0);
const [jumpCount, setJumpCount] = useState(0);
const [maxJumps, setMaxJumps] = useState(1);

// Abilities
const [hasExtraLife, setHasExtraLife] = useState(false);
const [canDestroyObstacles, setCanDestroyObstacles] = useState(false);
const [canFireBreath, setCanFireBreath] = useState(false);
const [canResurrect, setCanResurrect] = useState(false);
const [resurrected, setResurrected] = useState(false);

const [userEnergy, setUserEnergy] = useState(100);
const [dailyGems, setDailyGems] = useState(0);

// Animations
const petY = useRef(new Animated.Value(GROUND_HEIGHT)).current;
const petRotation = useRef(new Animated.Value(0)).current;
const petFlap = useRef(new Animated.Value(0)).current;
const gameLoop = useRef(null);
const spawnTimer = useRef(null);
const lastFrameTime = useRef(Date.now());

useEffect(() => {
loadGameData();
return () => {
if (gameLoop.current) cancelAnimationFrame(gameLoop.current);
if (spawnTimer.current) clearInterval(spawnTimer.current);
};
}, []);

const loadGameData = async () => {
try {
const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
const data = userDoc.data();
  const pet = data.pets;
  setPetData(pet);
  
  // Find pet configuration
  const config = STARTER_PETS.find(p => p.id === pet.id);
  setPetConfig(config);
  setIsFlying(config.category === 'flying');
  
  // Set abilities based on pet
  switch (config.runnerAbility.effect) {
    case 'tripleJump':
      setMaxJumps(3);
      break;
    case 'extraLife':
      setHasExtraLife(true);
      break;
    case 'destroyObstacles':
      setCanDestroyObstacles(true);
      break;
    case 'fireBreath':
      setCanFireBreath(true);
      break;
    case 'resurrect':
      setCanResurrect(true);
      break;
  }
  
  setHighScore(data.runnerBestScore || 0);
  setUserEnergy(data.energy || 100);
  setDailyGems(data.runnerDailyGems || 0);
} catch (error) {
  console.error('Error loading game data:', error);
}
};

const startGame = () => {
if (userEnergy < 5) {
Alert.alert('Not Enough Energy', 'You need 5 energy to play!');
return;
}
// Reset game
setScore(0);
setCoins(0);
setDistance(0);
setSpeed(INITIAL_SPEED);
setObstacles([]);
setPlatforms([]);
setCoinsList([]);
setPowerUps([]);
setJumpCount(0);
setVelocityY(0);
setIsOnGround(!isFlying);
setResurrected(false);

petY.setValue(isFlying ? GROUND_HEIGHT + 200 : GROUND_HEIGHT);
petRotation.setValue(0);
petFlap.setValue(0);
lastFrameTime.current = Date.now();

setGameState('playing');

spawnTimer.current = setInterval(spawnGameObjects, 1500);
gameLoop.current = requestAnimationFrame(updateGame);
};

const spawnGameObjects = () => {
const random = Math.random();

if (isFlying) {
  // Flying pet spawns
  if (random < 0.4) {
    spawnFlyingObstacle();
  } else if (random < 0.7) {
    spawnFloatingCoins();
  } else {
    spawnPowerUp();
  }
} else {
  // Land pet spawns
  if (random < 0.3) {
    spawnPlatform();
  } else if (random < 0.5) {
    spawnGroundObstacle();
  } else if (random < 0.7) {
    spawnCoins();
  } else {
    spawnPowerUp();
  }
}
};

const spawnPlatform = () => {
const height = 150 + Math.random() * 150;
const width = 80 + Math.random() * 60;
setPlatforms(prev => [...prev, {
  id: Date.now() + Math.random(),
  x: SCREEN_WIDTH,
  y: GROUND_HEIGHT + height,
  width,
  height: 20,
}]);

// Coins on platform
const coinCount = 3 + Math.floor(Math.random() * 3);
for (let i = 0; i < coinCount; i++) {
  setCoinsList(prev => [...prev, {
    id: Date.now() + Math.random() + i,
    x: SCREEN_WIDTH + (i * 35),
    y: GROUND_HEIGHT + height + 25,
    collected: false,
  }]);
}
};

const spawnGroundObstacle = () => {
const types = [
{ height: 50, width: 35, icon: 'ü™®', type: 'rock', destroyable: true },
{ height: 60, width: 30, icon: 'üåµ', type: 'cactus', destroyable: false },
{ height: 70, width: 40, icon: 'üî•', type: 'fire', destroyable: false },
{ height: 45, width: 45, icon: 'üíÄ', type: 'spike', destroyable: false },
];
const obstacle = types[Math.floor(Math.random() * types.length)];

setObstacles(prev => [...prev, {
  id: Date.now(),
  x: SCREEN_WIDTH,
  y: GROUND_HEIGHT,
  ...obstacle,
}]);
};

const spawnFlyingObstacle = () => {
const minHeight = 120;
const maxHeight = 350;
const height = minHeight + Math.random() * (maxHeight - minHeight);
const types = [
  { icon: 'ü¶Ö', width: 45, height: 40 },
  { icon: '‚òÅÔ∏è', width: 60, height: 50 },
  { icon: '‚ö°', width: 35, height: 45 },
  { icon: 'üå™Ô∏è', width: 50, height: 55 },
];

const obstacle = types[Math.floor(Math.random() * types.length)];

setObstacles(prev => [...prev, {
  id: Date.now(),
  x: SCREEN_WIDTH,
  y: GROUND_HEIGHT + height,
  ...obstacle,
  type: 'flying',
  destroyable: obstacle.icon === '‚òÅÔ∏è',
}]);
};

const spawnCoins = () => {
const pattern = Math.random() < 0.5 ? 'line' : 'arc';
const coinCount = 5;
const startHeight = 150 + Math.random() * 100;
for (let i = 0; i < coinCount; i++) {
  let y;
  if (pattern === 'line') {
    y = GROUND_HEIGHT + startHeight;
  } else {
    const progress = i / (coinCount - 1);
    const arcHeight = Math.sin(progress * Math.PI) * 80;
    y = GROUND_HEIGHT + startHeight + arcHeight;
  }

  setCoinsList(prev => [...prev, {
    id: Date.now() + i,
    x: SCREEN_WIDTH + (i * 40),
    y,
    collected: false,
  }]);
}
};

const spawnFloatingCoins = () => {
// For flying pets - more vertical variety
const centerHeight = 200 + Math.random() * 100;
const coinCount = 4;
for (let i = 0; i < coinCount; i++) {
  setCoinsList(prev => [...prev, {
    id: Date.now() + i,
    x: SCREEN_WIDTH + (i * 50),
    y: GROUND_HEIGHT + centerHeight + (Math.random() - 0.5) * 100,
    collected: false,
  }]);
}
};

const spawnPowerUp = () => {
const height = isFlying ?
200 + Math.random() * 100 :
150 + Math.random() * 100;
setPowerUps(prev => [...prev, {
  id: Date.now(),
  x: SCREEN_WIDTH,
  y: GROUND_HEIGHT + height,
  icon: '‚≠ê',
  type: 'invincible',
  collected: false,
}]);
};

const updateGame = () => {
const now = Date.now();
const deltaTime = Math.min((now - lastFrameTime.current) / 1000, 0.05);
lastFrameTime.current = now;
if (gameState !== 'playing') return;

setDistance(prev => prev + speed * deltaTime);
setScore(prev => prev + deltaTime * 10);
setSpeed(prev => Math.min(prev + deltaTime * 5, 450));

updatePlayerPhysics(deltaTime);
updateGameObjects(deltaTime);

gameLoop.current = requestAnimationFrame(updateGame);
};

const updatePlayerPhysics = (deltaTime) => {
if (isFlying) {
// Flying physics
setVelocityY(prev => {
const gravity = FLYING_GRAVITY * deltaTime;
const newVelocity = Math.min(prev + gravity, FLYING_MAX_FALL_SPEED);
const currentY = petY._value;
const newY = Math.max(
GROUND_HEIGHT + 50,
Math.min(currentY - newVelocity * deltaTime, GROUND_HEIGHT + 400)
);
    petY.setValue(newY);
    return newVelocity;
  });
} else {
  // Land physics
  setVelocityY(prev => {
    const newVelocity = prev + LAND_GRAVITY * deltaTime;
    const currentY = petY._value;
    const newY = currentY - newVelocity * deltaTime;

    if (newY <= GROUND_HEIGHT) {
      petY.setValue(GROUND_HEIGHT);
      setIsOnGround(true);
      setJumpCount(0);
      petRotation.setValue(0);
      return 0;
    }

    // Platform collision
    let onPlatform = false;
    platforms.forEach(platform => {
      if (checkPlatformCollision(currentY, newY, platform)) {
        petY.setValue(platform.y + platform.height);
        setIsOnGround(true);
        setJumpCount(0);
        onPlatform = true;
      }
    });

    if (!onPlatform && newY > GROUND_HEIGHT) {
      setIsOnGround(false);
      petY.setValue(newY);
    }

    return newVelocity;
  });
}
};

const checkPlatformCollision = (oldY, newY, platform) => {
const petX = 60;
const petRight = petX + PET_SIZE;
const platformLeft = platform.x;
const platformRight = platform.x + platform.width;
const horizontalOverlap = petRight > platformLeft && petX < platformRight;
const verticalOverlap = oldY > platform.y && newY <= platform.y + platform.height;

return horizontalOverlap && verticalOverlap && velocityY > 0;
};

const updateGameObjects = (deltaTime) => {
const moveDistance = speed * deltaTime;
};

const updateGameObjects = (deltaTime) => {
const moveDistance = speed * deltaTime;
// Obstacles
setObstacles(prev => {
  const updated = prev.map(obs => ({
    ...obs,
    x: obs.x - moveDistance,
  })).filter(obs => obs.x > -100);

  updated.forEach(obs => {
    if (checkObstacleCollision(obs)) {
      if (canDestroyObstacles && obs.destroyable) {
        // Bear destroys obstacles
        obs.x = -200; // Remove it
        setScore(s => s + 20);
      } else if (canFireBreath && obs.destroyable) {
        // Dragon burns obstacles
        obs.x = -200;
        setScore(s => s + 25);
      } else {
        handleHit();
      }
    }
  });

  return updated.filter(o => o.x > -200);
});

// Platforms
setPlatforms(prev => prev.map(p => ({
  ...p,
  x: p.x - moveDistance,
})).filter(p => p.x > -150));

// Coins
setCoinsList(prev => {
  const updated = prev.map(coin => ({
    ...coin,
    x: coin.x - moveDistance,
  })).filter(coin => coin.x > -30);

  updated.forEach(coin => {
    if (!coin.collected && checkCoinCollision(coin)) {
      coin.collected = true;
      setCoins(c => c + 1);
      setScore(s => s + 10);
    }
  });

  return updated.filter(c => !c.collected);
});

// Power-ups
setPowerUps(prev => prev.map(pu => ({
  ...pu,
  x: pu.x - moveDistance,
})).filter(pu => pu.x > -35));
};

const checkObstacleCollision = (obstacle) => {
const petX = 60;
const petBottom = petY._value;
const petTop = petBottom + PET_SIZE;
const petRight = petX + PET_SIZE;
const obsLeft = obstacle.x;
const obsRight = obstacle.x + obstacle.width;
const obsBottom = obstacle.y;
const obsTop = obstacle.y + obstacle.height;

return (
  petRight > obsLeft + 10 &&
  petX < obsRight - 10 &&
  petTop > obsBottom + 5 &&
  petBottom < obsTop - 5
);
};

const checkCoinCollision = (coin) => {
const petX = 60;
const petCenter = petY._value + PET_SIZE / 2;
const distance = Math.sqrt(
  Math.pow(petX + PET_SIZE / 2 - coin.x, 2) +
  Math.pow(petCenter - coin.y, 2)
);

return distance < 35;
};

const handleHit = () => {
if (hasExtraLife) {
// Cat's nine lives - one free hit
setHasExtraLife(false);
Alert.alert('üíö Extra Life Used!', 'Careful now!');
} else if (canResurrect && !resurrected) {
// Phoenix resurrection
setResurrected(true);
setScore(s => s + 100);
Alert.alert('üî• Phoenix Rebirth!', 'You rise from the ashes!');
} else {
endGame();
}
};

const jump = () => {
if (gameState !== 'playing') return;
if (isFlying) {
  // Flap for flying pets
  setVelocityY(FLYING_FLAP_FORCE);
  
  // Flap animation
  Animated.sequence([
    Animated.timing(petFlap, {
      toValue: 1,
      duration: 150,
      useNativeDriver: true,
    }),
    Animated.timing(petFlap, {
      toValue: 0,
      duration: 150,
      useNativeDriver: true,
    }),
  ]).start();
} else {
  // Jump for land pets
  const canJump = isOnGround || jumpCount < maxJumps;

  if (canJump) {
    const agilityBonus = (petData.baseStats.agility / 100) * 100;
    const jumpPower = LAND_JUMP_VELOCITY - agilityBonus;
    
    setVelocityY(jumpPower);
    setIsOnGround(false);
    setJumpCount(prev => prev + 1);

    // Rotation animation
    Animated.timing(petRotation, {
      toValue: petRotation._value + 360,
      duration: 500,
      easing: Easing.linear,
      useNativeDriver: true,
    }).start();
  }
}
};

const endGame = async () => {
setGameState('gameOver');
if (gameLoop.current) cancelAnimationFrame(gameLoop.current);
if (spawnTimer.current) clearInterval(spawnTimer.current);

const finalScore = Math.floor(score);
const finalCoins = coins;

try {
  await updateDoc(doc(db, 'users', auth.currentUser.uid), {
    energy: increment(-5),
  });

  const rewardResult = await calculateRunnerReward(
    auth.currentUser.uid, 
    finalScore + finalCoins * 2
  );

  if (finalScore > highScore) setHighScore(finalScore);

  showResults(finalScore, finalCoins, rewardResult);
} catch (error) {
  console.error('Error ending game:', error);
}
};

const showResults = (finalScore, finalCoins, rewardResult) => {
let message = Score: ${finalScore}\nCoins: ${finalCoins}\nDistance: ${Math.floor(distance)}m\n\n;
if (rewardResult.limitReached) {
  message += `‚ö†Ô∏è Daily limit (50/50)\n\nCome back tomorrow!`;
} else {
  message += `üíé Gems: ${rewardResult.gems}\n`;
  message += `Daily: ${dailyGems + rewardResult.gems}/50\n\n`;
  
  if (rewardResult.isNewHighScore) {
    message += `üéâ NEW HIGH SCORE!`;
  }
}

Alert.alert('Game Over!', message, [
  { text: 'Menu', onPress: () => navigation.goBack() },
  { text: 'Again', onPress: () => {
    loadGameData();
    setGameState('ready');
  }},
]);
};

if (!petConfig || gameState === 'ready') {
return (
<ScrollView style={styles.container}>
<View style={styles.header}>
<Text style={styles.title}>
{petConfig?.icon} {petConfig?.name}'s Adventure
</Text>
<Text style={styles.subtitle}>
{isFlying ? 'Fly through the skies!' : 'Run and jump!'}
</Text>
</View>
    <View style={styles.abilityCard}>
      <Text style={styles.abilityTitle}>
        ‚ú® Special Ability: {petConfig?.runnerAbility.name}
      </Text>
      <Text style={styles.abilityDesc}>
        {petConfig?.runnerAbility.description}
      </Text>
    </View>

    <View style={styles.infoCard}>
      <Text style={styles.infoTitle}>How to Play</Text>
      <Text style={styles.infoText}>
        {isFlying ? 'üéÆ Tap to flap wings and fly higher' : 'üéÆ Tap to jump over obstacles'}
      </Text>
      <Text style={styles.infoText}>üíé Collect coins for points</Text>
      <Text style={styles.infoText}>‚≠ê Grab power-ups</Text>
      <Text style={styles.infoText}>üèÜ Survive as long as possible</Text>
    </View>

    <View style={styles.statsCard}>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>üèÜ High Score</Text>
        <Text style={styles.statValue}>{highScore}</Text>
      </View>
      <View style={styles.statRow}>
        <Text style={styles.statLabel}>üíé Today</Text>
        <Text style={styles.statValue}>{dailyGems}/50</Text>
      </View>
    </View>

    <TouchableOpacity
      style={styles.startBtn}
      onPress={startGame}
      disabled={userEnergy < 5}
    >
      <Text style={styles.startBtnText}>
        {userEnergy < 5 ? 'Need 5 Energy' : '‚ñ∂Ô∏è Start Adventure'}
      </Text>
    </TouchableOpacity>

    <TouchableOpacity
      style={styles.backBtn}
      onPress={() => navigation.goBack()}
    >
      <Text style={styles.backBtnText}>‚Üê Back</Text>
    </TouchableOpacity>
  </ScrollView>
);
}

// GAME SCREEN
const rotation = petRotation.interpolate({
inputRange: ,
outputRange: ['0deg', '360deg'],
});

const flapScale = petFlap.interpolate({
inputRange:,‚Äã
outputRange: [1, 0.9],
});

const currentIcon = isFlying ?
(velocityY < 0 ? petConfig.flyingIcon : petConfig.glidingIcon) :
(isOnGround ? petConfig.runningIcon : petConfig.jumpingIcon);

return (
<TouchableOpacity style={styles.gameContainer} activeOpacity={1} onPress={jump} >
{/* HUD */}
<View style={styles.hud}>
<Text style={styles.hudText}>Score: {Math.floor(score)}</Text>
<Text style={styles.hudText}>üíé {coins}</Text>
<Text style={styles.hudText}>{Math.floor(distance)}m</Text>
</View>
  {/* Ability status */}
  {hasExtraLife && (
    <View style={styles.abilityIndicator}>
      <Text style={styles.abilityText}>üíö Extra Life</Text>
    </View>
  )}
  {resurrected && (
    <View style={styles.abilityIndicator}>
      <Text style={styles.abilityText}>üî• Reborn</Text>
    </View>
  )}

  <View style={[styles.gameArea, { height: GAME_HEIGHT }]}>
    <View style={styles.sky} />

    {/* Platforms (land only) */}
    {!isFlying && platforms.map(platform => (
      <View
        key={platform.id}
        style={[
          styles.platform,
          {
            left: platform.x,
            bottom: platform.y - GROUND_HEIGHT,
            width: platform.width,
            height: platform.height,
          },
        ]}
      />
    ))}

    {/* Coins */}
    {coinsList.map(coin => (
      <Text
        key={coin.id}
        style={[
          styles.coin,
          {
            left: coin.x,
            bottom: coin.y - GROUND_HEIGHT,
          },
        ]}
      >
        üíé
      </Text>
    ))}

    {/* Obstacles */}
    {obstacles.map(obs => (
      <View
        key={obs.id}
        style={[
          styles.obstacle,
          {
            left: obs.x,
            bottom: obs.y - GROUND_HEIGHT,
            width: obs.width,
            height: obs.height,
          },
        ]}
      >
        <Text style={styles.obstacleIcon}>{obs.icon}</Text>
      </View>
    ))}

    {/* Pet */}
    <Animated.View
      style={[
        styles.pet,
        {
          bottom: Animated.subtract(petY, GROUND_HEIGHT),
          transform: isFlying ? 
            [{ scale: flapScale }] : 
            [{ rotate: rotation }],
        },
      ]}
    >
      <Text style={styles.petIcon}>{currentIcon}</Text>
    </Animated.View>

    {/* Ground */}
    <View style={styles.ground}>
      <View style={styles.groundPattern} />
    </View>
  </View>

  {/* Instructions */}
  <View style={styles.instructions}>
    <Text style={styles.instructionText}>
      {isFlying ? 'üëÜ TAP TO FLAP' : 'üëÜ TAP TO JUMP'}
    </Text>
    {maxJumps > 1 && !isFlying && (
      <Text style={styles.instructionSubtext}>
        {maxJumps} jumps available!
      </Text>
    )}
  </View>
</TouchableOpacity>
);
}

// Styles remain the same...
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#F5F5F5',
},
header: {
backgroundColor: '#A463BF',
padding: 30,
alignItems: 'center',
},
title: {
fontSize: 26,
fontWeight: 'bold',
color: 'white',
marginBottom: 5,
},
subtitle: {
fontSize: 16,
color: 'rgba(255,255,255,0.9)',
},
abilityCard: {
backgroundColor: '#FFE082',
margin: 20,
padding: 15,
borderRadius: 12,
borderWidth: 2,
borderColor: '#FFA000',
},
abilityTitle: {
fontSize: 16,
fontWeight: 'bold',
color: '#F57C00',
marginBottom: 5,
},
abilityDesc: {
fontSize: 14,
color: '#666',
},
infoCard: {
backgroundColor: 'white',
marginHorizontal: 20,
marginBottom: 20,
padding: 20,
borderRadius: 12,
},
infoTitle: {
fontSize: 18,
fontWeight: 'bold',
marginBottom: 12,
color: '#333',
},
infoText: {
fontSize: 14,
color: '#666',
marginBottom: 6,
},
statsCard: {
backgroundColor: 'white',
marginHorizontal: 20,
marginBottom: 20,
padding: 15,
borderRadius: 12,
},
statRow: {
flexDirection: 'row',
justifyContent: 'space-between',
paddingVertical: 10,
},
statLabel: {
fontSize: 14,
color: '#666',
},
statValue: {
fontSize: 14,
fontWeight: 'bold',
color: '#A463BF',
},
startBtn: {
backgroundColor: '#A463BF',
marginHorizontal: 20,
marginBottom: 15,
padding: 18,
borderRadius: 12,
alignItems: 'center',
},
startBtnText: {
color: 'white',
fontSize: 18,
fontWeight: 'bold',
},
backBtn: {
marginHorizontal: 20,
marginBottom: 30,
padding: 15,
alignItems: 'center',
},
backBtnText: {
color: '#A463BF',
fontSize: 16,
},
gameContainer: {
flex: 1,
backgroundColor: '#87CEEB',
},
hud: {
position: 'absolute',
top: 40,
left: 0,
right: 0,
flexDirection: 'row',
justifyContent: 'space-around',
zIndex: 10,
},
hudText: {
fontSize: 18,
fontWeight: 'bold',
color: 'white',
textShadowColor: 'rgba(0,0,0,0.5)',
textShadowOffset: { width: 1, height: 1 },
textShadowRadius: 3,
},
abilityIndicator: {
position: 'absolute',
top: 80,
left: 20,
backgroundColor: 'rgba(255,215,0,0.8)',
paddingHorizontal: 12,
paddingVertical: 6,
borderRadius: 15,
zIndex: 10,
},
abilityText: {
fontSize: 12,
fontWeight: 'bold',
color: '#333',
},
gameArea: {
width: '100%',
position: 'relative',
marginTop: 120,
},
sky: {
position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: GROUND_HEIGHT,
backgroundColor: '#87CEEB',
},
ground: {
position: 'absolute',
bottom: 0,
left: 0,
right: 0,
height: GROUND_HEIGHT,
backgroundColor: '#8B7355',
},
groundPattern: {
height: 3,
backgroundColor: '#654321',
},
pet: {
position: 'absolute',
left: 60,
width: PET_SIZE,
height: PET_SIZE,
justifyContent: 'center',
alignItems: 'center',
},
petIcon: {
fontSize: 45,
},
platform: {
position: 'absolute',
backgroundColor: '#8B4513',
borderRadius: 5,
borderTopWidth: 3,
borderTopColor: '#A0522D',
},
coin: {
position: 'absolute',
fontSize: 25,
},
obstacle: {
position: 'absolute',
justifyContent: 'center',
alignItems: 'center',
},
obstacleIcon: {
fontSize: 40,
},
instructions: {
position: 'absolute',
bottom: 30,
width: '100%',
alignItems: 'center',
},
instructionText: {
fontSize: 22,
fontWeight: 'bold',
color: 'white',
textShadowColor: 'rgba(0,0,0,0.5)',
textShadowOffset: { width: 2, height: 2 },
textShadowRadius: 4,
},
instructionSubtext: {
fontSize: 14,
color: '#FFD700',
fontWeight: 'bold',
marginTop: 5,
},
});